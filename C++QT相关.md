# C++基础知识



## 内存分区模型

C++程序在执行时候，将内存大方向划分为**四个区域：**

- 代码区：存放函数体的二进制代码
- 全局区：存放全局变量和静态变量以及常量
- 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等
- 堆区：由程序员分配和释放，若程序员不释放，程序结束由操作系统回收（new操作符开辟）







引用和指针的区别

## ✅ 一、引用 `&` vs 指针 `*`

| 特性             | 引用 `&`                   | 指针 `*`                  |
| ---------------- | -------------------------- | ------------------------- |
| 是否可为 null？  | ❌ 否，必须绑定一个有效对象 | ✅ 可以为 `nullptr`        |
| 语法简洁性       | ✅ 更简洁，像值一样使用     | ❌ 使用麻烦（需解引用）    |
| 可修改绑定对象？ | ✅ 可（除非加 `const`）     | ✅ 可                      |
| 是否能重新绑定？ | ❌ 一经绑定不可更改         | ✅ 可以指向别的对象        |
| 空值判断         | ❌ 无需判断是否为 null      | ✅ 通常需要判断是否为 null |

### 何时使用引用何时使用指针？

#### 1.何时使用引用 `&`

**使用 `const QImage &image`：**

- 参数**必须存在、不可为空**
- 你只需要**读取数据**
- 你希望**性能好且写法清晰**

###  2.何时使用指针 `QImage*`

**使用 `QImage* image`**

- 参数**可能为 null**（可选项）
- 你需要**在函数内部创建或修改**传入的对象
- 你希望函数**有可能影响原始对象**

**使用信号时候优先选择引用**	





## 多态

分为两类：

1. 静态多态：函数重载和运算符重载属于静态，复用函数名字
2. 动态多态：派生类和虚函数实现运行时候多态

静态多态与动态多态区别：

1. 静态多态的函数地址早绑定， 编译阶段确定函数地址
2. 动态多态的函数地址晚绑定，运行阶段确定函数地址

多态的优点：

* 代码组织结构清晰
* 可读性强
* 利于前期和后期的扩展以及维护



### 纯虚函数和抽象类

在多态中，通常父类的虚函数的实现是毫无意义的，主要是调用子类重写的内容



因此可以将虚函数改为**纯虚函数**

语法： virtual 返回值类型 函数名 （参数列表）=0；

当类中有了纯虚函数这个类也称为**抽象类**



**抽象类特点**：

- **无法实例化**对象
- 子类**必须重写**抽象类中的纯虚函数，**否则也属于**抽象类





### 虚析构函数和纯虚析构



多态使用时候 如果子类中有属性开辟到堆区，那么父类指针释放时候无法调用到子类的析构代码

解决方法：将父类的析构函数改为**虚析构**或者**纯虚析构**

虚析构和纯虚析构共性质：

- 可以解决父类指针释放子类对象
- 都需要有具体的函数实现

虚析构和纯虚析构的区别：

- 如果是纯虚析构，那么该类属于抽象类，无法实例化对象

**虚析构语法**：

​	virtual ~类名（）{}

**纯虚析构语法：**

virtual ~类名（）= 0；





**总结：**

​	1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象

​	2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构

	3. 拥有纯虚析构函数的类**也属于抽象类







## 文件操作

程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放

通过**文件可以将数据持久化**

C++中对文件操作需要包含头文件 ==&lt; fstream &gt;==



文件类型分为两种：

1. 文本文件 文件以文本的ASCII码存储在计算机中
2. 二进制文件 文件以文本的二进制形式存储在计算机中



操作文件的三大类:

1. ofstream：写操作
2. ifstream： 读操作
3. fstream ： 读写操作





## 模板

**概念：**

模板就是建立**通用的模具**，大大**提高复用性**



**特点：**

- 模板不可以直接使用，它只是一个框架
- 模板的通用并不是万能的



### 函数模板





### 类模板
